using System.Collections;
using System.Collections.Immutable;
using System.Data;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;

[assembly: InternalsVisibleTo("IMP.Tests")]
namespace IMP;

public class Parser(IEnumerable<Rule<string, string>> rules, Lexer<string> lexer) : Parser<string, string>(rules, lexer) {}

public class Parser<TNonTerm, TTerm> where TNonTerm : notnull where TTerm : notnull
{
	internal readonly RuleSet<TNonTerm, TTerm> _rules;
	private readonly Lexer<TTerm> _lexer;

	public Parser(IEnumerable<Rule<TNonTerm, TTerm>> rules, Lexer<TTerm> lexer) => (_rules, _lexer) = (new(rules), lexer);

	public ResultTree? ParseClassic(TNonTerm start, string input, IEnumerable<Regex>? absorb = null)
	{
		var tweSet = _lexer.Lex(input, absorb);

		ResultTree? TryParse(Rule<TNonTerm, TTerm> rule, Index left, List<ResultTree>? children = null)
		{
			children ??= [];

			if (rule.Head is Rule<TNonTerm, TTerm>.RuleTerminal rt)
			{
				// Terminal; match and continue
				var tweElems = tweSet.Where(si => si.Extents.Start.Equals(left) && si.Token.Equals(rt.Terminal));
				if (!tweElems.Any())
					return null;

				var res = tweElems.MaxBy(e => e.Extents.End.Value)!;
				children.Add(new(null, new(res.Extents, res.Token, res.Lexeme), []));
				left = res.Extents.End;
				return TryParse(rule.Tail, left, children);
			}
			else if (rule.Head is Rule<TNonTerm, TTerm>.RuleNonTerminal rnt)
			{
				var subtrees = _rules[rnt.NonTerminal].Select(r => TryParse(r, left)).ToArray();

				// NonTerminal; match and continue
				if (subtrees.Length == 0)
					return null;

				ResultTree? res = subtrees.MaxBy(t => t.HasValue ? t.Value.Extents.End.Value : -1);
				if (res is null)
					return null;

				children.Add(res.Value);
				left = res.Value.Root!.Extents.End;
				return TryParse(rule.Tail, left, children);
			}
			else
			{
				// End of nonterminal alternate; calculate extents and return
				var extents =
					children.Count != 0
					? children.Select(c => c.Extents.Start.Value).Min()..children.Select(c => c.Extents.End.Value).Max()
					: left..left;

				return new(new(extents, rule.NonTerminal, input[extents]), null, [.. children]);
			}
		}

		return _rules[start].Select(r => TryParse(r, 0)).MaxBy(t => t.HasValue ? t.Value.Extents.End.Value : -1);
	}

	/// <summary>Pre-baked longest-within chooser.</summary>
	/// <seealso cref="Parse(TNonTerm, string, IEnumerable{Regex}?, Func{IEnumerable{TweTriple{TTerm}}, IEnumerable{TweTriple{TTerm}}}?)"/>
	public static Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>> LongestMatchWithin =>
		tweset =>
			tweset.GroupBy(e => e.Extents.Start.Value).AsParallel()
			.SelectMany(g => g.Where(i => !g.Any(j => i.Extents.End.Value < j.Extents.End.Value && i.Token.Equals(j.Token))));

	/// <summary>Pre-baked longest-across chooser.</summary>
	/// <seealso cref="Parse(TNonTerm, string, IEnumerable{Regex}?, Func{IEnumerable{TweTriple{TTerm}}, IEnumerable{TweTriple{TTerm}}}?)"/>
	public static Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>> LongestMatchAcross =>
		tweset =>
			LongestMatchWithin(tweset).GroupBy(e => e.Extents.Start.Value).AsParallel()
			.SelectMany(g => { var m = g.Max(i => i.Extents.End.Value); return g.Where(i => i.Extents.End.Value == m); });

	/// <summary>Pre-baked dead-branch pruning chooser.</summary>
	/// <seealso cref="Parse(TNonTerm, string, IEnumerable{Regex}?, Func{IEnumerable{TweTriple{TTerm}}, IEnumerable{TweTriple{TTerm}}}?)"/>
	public static Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>> DeadBranchPrune =>
		tweset =>
		{
			for (int prevCount = -1; prevCount != (prevCount = tweset.Count());)
				tweset = tweset.AsParallel().Where(e => e.Extents.Start.Value == 0 || tweset.Any(e2 => e.Extents.Start.Value == e2.Extents.End.Value)).ToArray();

			return tweset;
		};

	/// <summary>A pipeline which applies <see cref="LongestMatchAcross"/>, then <see cref="DeadBranchPrune"/>.</summary>
	public static Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>> LongestMatchDeadBranchPrune =>
		tweset => DeadBranchPrune(LongestMatchAcross(tweset));

	/// <summary>Multiparses the provided <paramref name="input"/>.</summary>
	/// <param name="startSymbol">The start symbol from which to derive the tree.</param>
	/// <param name="input">The input to be parsed.</param>
	/// <param name="parseForest">The <see cref="SPPFNode"/> generated by the parse. If the parse failed, this returns the longest parseable segment from the start of the <paramref name="input"/>.</param>
	/// <param name="failurePoint">If the parse failed, this returns the index at which the parse failed as well as what <see cref="Rule{TNonTerm, TTerm}"/> the parser was working on at that point.</param>
	/// <param name="absorb">Optionally, any tokens to be absorbed.</param>
	/// <returns>All parse trees.</returns>
	public bool TryParse(TNonTerm startSymbol, string input, [NotNullWhen(true)] out SPPFNode? parseForest, [NotNullWhen(false)] out (int Index, Rule<TNonTerm, TTerm>? ParsePoint)? failurePoint, IEnumerable<Regex>? absorb = null, Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>>? chooser = null, bool classicalLexing = false)
	{
		chooser ??= a => a;
		ImmutableList<TweTriple<TTerm>> tweSet;
		try
		{
			var fullset = _lexer.Lex(input, absorb, classicalLexing);
			tweSet = [.. chooser(fullset).OrderBy(t => t.Extents.Start.Value)];
		}
		catch (ArgumentException ae) when (int.TryParse(ae.Message.Split()[0], out int failIdx))
		{
			failurePoint = (failIdx, null);
			parseForest = null;
			return false;
		}

		return ParseInternal(startSymbol, tweSet, out parseForest, out failurePoint, absorb);
	}


	/// <summary>Multiparses the provided <paramref name="input"/>.</summary>
	/// <param name="startSymbol">The start symbol from which to derive the tree.</param>
	/// <param name="input">The input to be parsed.</param>
	/// <param name="parseForest">The <see cref="SPPFNode"/> generated by the parse. If the parse failed, this returns the longest parseable segment from the start of the <paramref name="input"/>.</param>
	/// <param name="failurePoint">If the parse failed, this returns the index at which the parse failed as well as what <see cref="Rule{TNonTerm, TTerm}"/> the parser was working on at that point.</param>
	/// <param name="absorb">Optionally, any tokens to be absorbed.</param>
	/// <returns>All parse trees.</returns>
	public bool TryParse(TNonTerm startSymbol, IEnumerable<TTerm> input, [NotNullWhen(true)] out SPPFNode? parseForest, [NotNullWhen(false)] out (int Index, Rule<TNonTerm, TTerm>? ParsePoint)? failurePoint, IEnumerable<Regex>? absorb = null)
	{
		int curIdx = 0;
		TweTriple<TTerm> Convert(TTerm ip) => new(curIdx..(++curIdx), ip, "");

		return ParseInternal(startSymbol, input.Select(Convert).ToImmutableList(), out parseForest, out failurePoint, absorb);
	}

	private bool ParseInternal(TNonTerm startSymbol, ImmutableList<TweTriple<TTerm>> tweSet, [NotNullWhen(true)] out SPPFNode? parseForest, [NotNullWhen(false)] out (int Index, Rule<TNonTerm, TTerm>? ParsePoint)? failurePoint, IEnumerable<Regex>? absorb)
	{
		failurePoint = null;

		IEnumerable<TweTriple<TTerm>> getElems(Index left) =>
				tweSet.Where(se => se.Extents.Start.Value == left.Value);

		HashSet<GSSNode> nodes = [];
		HashSet<(Rule<TNonTerm, TTerm>, GSSNode?, Index, SPPFNode?)> processedDescriptors = [];
		HashSet<(GSSNode?, SPPFNode?)> poppedNodes = [];
		HashSet<SPPFNode> sppf = [];

		Stack<(Rule<TNonTerm, TTerm>, GSSNode?, Index, SPPFNode?)> descriptors = new();

		T createOrGet<T>(T node) where T : SPPFNode
		{
			if (sppf.FirstOrDefault(sn => sn.Equals(node)) is T retval)
				return retval;

			sppf.Add(node);
			return node;
		}

		SymbolNode getNodeT(Rule<TNonTerm, TTerm>.RuleItem symbol, Range extents, Range unabsorbedExtents) =>
			createOrGet<SymbolNode>(new(symbol, extents, unabsorbedExtents));

		SPPFNode getNodeP(Rule<TNonTerm, TTerm> slot, SPPFNode? left, SPPFNode right)
		{
			if (left is null && slot.SlotPosition == 1 && slot.Any())
				return right;

			var retrange = (left ?? right).GetExtents().Start..right.GetExtents().End;
			SPPFNode retnode =
				slot.Any()
				? new IntermediateNode(slot, retrange)
				: new SymbolNode(new Rule<TNonTerm, TTerm>.RuleNonTerminal(slot.NonTerminal), retrange, retrange);

			retnode = createOrGet(retnode);
			retnode.AddChild(createOrGet(new PackedNode(slot, right.GetExtents().Start, left, right)));
			return retnode;
		}

		void add(Rule<TNonTerm, TTerm> slot, GSSNode? stack, Index i, SPPFNode? currentNode)
		{
			var descriptor = (slot, stack, i, currentNode);
			if (!processedDescriptors.Contains(descriptor))
			{
				descriptors.Push(descriptor);
				processedDescriptors.Add(descriptor);
			}
		}

		void pop(GSSNode? stack, Index i, SPPFNode currentNode)
		{
			if (stack is null)
				return;

			poppedNodes.Add((stack, currentNode));

			foreach (var (v, w) in stack.Edges)
				add(stack.Element, v, i, getNodeP(stack.Element, w, currentNode));
		}

		GSSNode create(Rule<TNonTerm, TTerm> slot, GSSNode? stack, Index i, SPPFNode? currentNode)
		{
			GSSNode newNode = new(slot, i);
			if (!nodes.Add(newNode))
				newNode = nodes.Single(n => n.Equals(newNode));

			newNode.AddEdge(stack, currentNode);
			SemaphoreSlim _createSemaphore = new(1);

			foreach (var z in poppedNodes.AsParallel().AsUnordered().Where(p => p.Item1?.Equals(newNode) ?? false).Select(i => i.Item2))
			{
				Index rightExt = z! switch {
					IntermediateNode inode => inode.Extents.End,
					SymbolNode snode => snode.Extents.End,
					_ => throw new Exception()
				};

				add(slot, stack, rightExt, getNodeP(slot, currentNode, z!));
			}

			return newNode;
		}

		void execute(Rule<TNonTerm, TTerm> slot, GSSNode? stack, Index i, SPPFNode? currentNode)
		{
			switch (slot.Head)
			{
				case null:
					if (slot.SlotPosition == 0)
						// Eps alternate
						currentNode = getNodeP(slot, currentNode, getNodeT(new Rule<TNonTerm, TTerm>.RuleTerminal(default), i..i, i..i));

					pop(stack, i, currentNode!);
					break;

				case Rule<TNonTerm, TTerm>.RuleTerminal term:
					foreach (var e in getElems(i).Where(se => se.Token.Equals(term.Terminal)))
						add(slot.Tail, stack, e.Extents.End, getNodeP(slot.Tail, currentNode, getNodeT(term, e.Extents, e.UnabsorbedSpan)));
					break;

				case Rule<TNonTerm, TTerm>.RuleNonTerminal nonterm:
					var newstack = create(slot.Tail, stack, i, currentNode);

					foreach (var r in _rules[nonterm.NonTerminal])
						switch (r.Head)
						{
							case null:
								add(r, newstack, i, null);
								break;

							case Rule<TNonTerm, TTerm>.RuleNonTerminal nt when _rules.Test(nt.NonTerminal).Any(t => getElems(i).Any(se => se.Token.Equals(t))):
								add(r, newstack, i, null);
								break;

							case Rule<TNonTerm, TTerm>.RuleTerminal t when getElems(i).Any(se => se.Token.Equals(t.Terminal)):
								add(r, newstack, i, null);
								break;
						}
					break;
			}
		}

		bool emptyFileWithNullableRule = false;

		// Process start symbol specially to prevent hanging SPPF nodes.
		foreach (var r in _rules[startSymbol])
			if ((r.Head is null && tweSet.Count == 0)
			 || (r.Head is Rule<TNonTerm, TTerm>.RuleNonTerminal nt && _rules.Test(nt.NonTerminal).Any(t => getElems(0).Any(se => se.Token.Equals(t))))
			 || (r.Head is Rule<TNonTerm, TTerm>.RuleTerminal t && getElems(0).Any(se => se.Token.Equals(t.Terminal))))
			{
				emptyFileWithNullableRule = r.Head is null && tweSet.Count == 0;
				add(r, null, 0, null);
			}

		if (descriptors.Count == 0)
		{
			parseForest = null;
			failurePoint = (0, new(startSymbol));
			return false;
		}

#if DEBUG
		int maxDescriptors = descriptors.Count;
#endif
		while (descriptors.TryPop(out var d))
		{
			var (slot, stack, i, currentNode) = d;

			execute(slot, stack, i, currentNode);

#if DEBUG
			if (descriptors.Count > maxDescriptors)
				maxDescriptors = descriptors.Count;
#endif
		}

#if DEBUG
		System.Diagnostics.Debug.WriteLine($"Maxed out at {maxDescriptors} descriptors.");
#endif

		var startingTrees = sppf.Where(n => n is SymbolNode sn && !sn.IsTerminal).Cast<SymbolNode>().OrderByDescending(v => v.Extents.End.Value - v.Extents.Start.Value).ToArray();

		if (emptyFileWithNullableRule)
		{
			parseForest = startingTrees.OrderByDescending(t => t.GraphViz.Length).First();
			return true;
		}
		else if (startingTrees.SingleOrDefault(sn => sn.Extents.Start.Value == 0 && ((Rule<TNonTerm, TTerm>.RuleNonTerminal)sn.Symbol).NonTerminal.Equals(startSymbol) && sn.Extents.End.Value == tweSet.Max(e => e.Extents.End.Value)) is SPPFNode retval)
		{
			parseForest = retval;
			return true;
		}

		var allDerivations = sppf.Where(n => n is not PackedNode).OrderByDescending(v => { var e = v.GetExtents(); return e.End.Value - e.Start.Value; }).ToArray();
		var failureNode = sppf.Where(n => n is not SymbolNode && n.GetExtents().Start.Value == 0).OrderByDescending(v => v.GetExtents().End.Value).FirstOrDefault();

		parseForest = failureNode ?? allDerivations.FirstOrDefault();
		var backupDescriptor = processedDescriptors.Where(d => d.Item4?.Equals(allDerivations.FirstOrDefault()) ?? false).FirstOrDefault();

		failurePoint = failureNode switch {
			PackedNode pn => (pn.GetExtents().End.Value, pn.Slot),
			IntermediateNode @in => (@in.Extents.End.Value, @in.Slot),
			null => (backupDescriptor.Item3.Value, backupDescriptor.Item1),
			_ => throw new NotImplementedException()
		};

		return false;
	}

	public SPPFNode? Parse(TNonTerm startSymbol, string input, IEnumerable<Regex>? absorb = null, Func<IEnumerable<TweTriple<TTerm>>, IEnumerable<TweTriple<TTerm>>>? chooser = null, bool classicalLexing = false) =>
		TryParse(startSymbol, input, out var forest, out _, absorb, chooser, classicalLexing)
		? forest
		: null;

	public record struct ResultTree(TweTriple<TNonTerm>? Root, TweTriple<TTerm?>? Leaf, ResultTree[] Children)
	{
		[property: MemberNotNullWhen(true, nameof(Leaf))]
		[property: MemberNotNullWhen(false, nameof(Root))]
		public readonly bool IsLeaf => Root is null && Leaf is not null;
		[property: MemberNotNullWhen(true, nameof(Root))]
		[property: MemberNotNullWhen(false, nameof(Leaf))]
		public readonly bool IsRoot => Leaf is null && Root is not null;

		public readonly Range Extents => IsRoot ? Root.Extents : Leaf.Extents;

		public override readonly string ToString() =>
			$"{(IsLeaf ? Leaf : Root)}({string.Join(", ", Children?.Select(c => c.ToString()) ?? [])})";

		public override readonly int GetHashCode() =>
			HashCode.Combine(Root?.GetHashCode() ?? Leaf?.GetHashCode() ?? 0, ((IStructuralEquatable)Children).GetHashCode(EqualityComparer<ResultTree>.Default));

		public readonly string GraphViz
		{
			get
			{
				List<string> nodeDefs = [];
				List<string> edges = [];

				Queue<ResultTree> frontier = new();
				HashSet<int> checkedNodes = [];
				frontier.Enqueue(this);

				while (frontier.TryDequeue(out ResultTree current))
				{
					if (checkedNodes.Contains(current.GetHashCode()))
						continue;

					nodeDefs.Add($"{current.GetHashCode()} [ label=\"{(current.IsRoot ? current.Root.ToString() : current.IsLeaf ? current.Leaf.ToString() : "?").Replace("\\", @"\\").Replace("\"", @"\""").ReplaceLineEndings(@"\n")}\" ];");

					if (current.IsRoot)
						foreach (var c in current.Children)
						{
							frontier.Enqueue(c);
							edges.Add($"{current.GetHashCode()} -> {c.GetHashCode()};");
						}
				}

				return
					"digraph G {\n\t" +
					string.Join(Environment.NewLine + "\t", nodeDefs) +
					Environment.NewLine +
					"\n\t" + string.Join(Environment.NewLine + "\t", edges) +
					Environment.NewLine +
					"}";
			}
		}
	}

	private sealed record GSSNode(Rule<TNonTerm, TTerm> Element, Index Index)
	{
		public override string ToString() => $"<{Element}, {Index}>";

		public bool Equals(GSSNode? other) =>
			other is not null && GetHashCode() == other.GetHashCode();

		public override int GetHashCode() =>
			HashCode.Combine(Element.GetHashCode(), Index);

		public IEnumerable<(GSSNode?, SPPFNode?)> Edges => [.. _edges];

		readonly HashSet<(GSSNode?, SPPFNode?)> _edges = [];

		public void AddEdge(GSSNode? endpoint, SPPFNode? label) =>
			_edges.Add((endpoint, label));
	}

	public abstract record SPPFNode
	{
		public virtual IEnumerable<SPPFNode> Children => _children;
		public virtual bool Equals(SPPFNode? other) => GetHashCode() == other?.GetHashCode();
		public abstract override int GetHashCode();
		public abstract override string ToString();
		public abstract Range GetExtents();

		public virtual void AddChild(SPPFNode child)
		{
			if (!_children.Any(cn => cn.Equals(child)))
				_children.Add(child);
		}

		private readonly List<SPPFNode> _children = [];

		/// <summary>Gets all derivations in the forest as <see cref="ResultTree">ResultTrees</see>.</summary>
		/// <remarks>May not terminate (or terminate incorrectly) if there are infinitely many derivations possible.</remarks>
		public ResultTree[] GetTrees(string input)
		{
			ResultTree[][] Unpack(SPPFNode[] children)
			{
				if (children.Length == 0)
					return [[]];

				ResultTree[][] following = [.. Unpack(children[1..])];

				return children.First().GetTrees(input)
					.SelectMany(t => following.Select(f => (!t.IsRoot && !t.IsLeaf ? t.Children.Concat(f) : f.Prepend(t)).ToArray())).ToArray();
			}

			return this switch {
				SymbolNode snode when _children.Count == 0 => [ new(
										null,
										new(snode.Extents, ((Rule<TNonTerm, TTerm>.RuleTerminal)snode.Symbol).Terminal, input.Length == 0 ? "" : input[snode.UnabsorbedExtents]),
										[]
									)],
				
				SymbolNode snode => [.. snode.Children.SelectMany(c => Unpack(c.Children).Select(u =>
										new ResultTree(new(snode.Extents, ((Rule<TNonTerm, TTerm>.RuleNonTerminal)snode.Symbol).NonTerminal, input.Length == 0 ? "" : input[snode.Extents]), null, u)
									))],

				IntermediateNode inode => inode.Children.SelectMany(c => c.GetTrees(input)).ToArray(),

				PackedNode pnode => Unpack(pnode.Children).Select(n => new ResultTree(null, null, n)).ToArray(),

				_ => throw new Exception(GraphViz)
			};
		}

		public string GraphViz
		{
			get
			{
				List<string> nodeDefs = [];
				List<string> edges = [];

				Queue<SPPFNode> frontier = new();
				HashSet<SPPFNode> checkedNodes = [];
				frontier.Enqueue(this);

				while (frontier.TryDequeue(out SPPFNode? current))
				{
					nodeDefs.Add($"{current.GetHashCode().ToString(CultureInfo.InvariantCulture)} [ label=\"{(current is PackedNode pn ? $"@ {pn.Pivot}" : $"{current}").Replace("\\", @"\\").Replace("\"", @"\""").ReplaceLineEndings(@"\n")}\" ];");

					foreach (var c in current.Children)
					{
						if (checkedNodes.Any(cn => cn.Equals(current)))
							continue;

						frontier.Enqueue(c);
						edges.Add($"{current.GetHashCode().ToString(CultureInfo.InvariantCulture)} -> {c.GetHashCode().ToString(CultureInfo.InvariantCulture)};");
					}
					checkedNodes.Add(current);
				}

				return
					"digraph G {\n\t" +
					string.Join(Environment.NewLine + "\t", nodeDefs) +
					Environment.NewLine +
					"\n\t" + string.Join(Environment.NewLine + "\t", edges) +
					Environment.NewLine +
					"}";
			}
		}
	}

	public sealed record SymbolNode(Rule<TNonTerm, TTerm>.RuleItem Symbol, Range Extents, Range UnabsorbedExtents) : SPPFNode
	{
		public override int GetHashCode() => HashCode.Combine(Symbol.GetHashCode(), HashCode.Combine(Extents.Start.Value, Extents.End.Value), HashCode.Combine(UnabsorbedExtents.Start.Value, UnabsorbedExtents.End.Value));
		public override Range GetExtents() => Extents;

		public new IEnumerable<PackedNode> Children => base.Children.Cast<PackedNode>();

		public bool IsTerminal => Symbol is Rule<TNonTerm, TTerm>.RuleTerminal;

		public override string ToString() =>
			$"<{Symbol}, {Extents.Start}..{Extents.End}>";
	}

	public sealed record IntermediateNode(Rule<TNonTerm, TTerm> Slot, Range Extents) : SPPFNode
	{
		public override int GetHashCode() => HashCode.Combine(Slot.GetHashCode(), HashCode.Combine(Extents.Start.Value, Extents.End.Value));
		public override Range GetExtents() => Extents;

		public new IEnumerable<PackedNode> Children => base.Children.Cast<PackedNode>();

		public override string ToString() =>
			$"<{Slot}, {Extents.Start}..{Extents.End}>";
	}

	public sealed record PackedNode(Rule<TNonTerm, TTerm> Slot, Index Pivot, SPPFNode? LeftChild, SPPFNode RightChild) : SPPFNode
	{
		public override SPPFNode[] Children =>
			LeftChild is null
			? new[] { RightChild }
			: [LeftChild!, RightChild];

		public override int GetHashCode() => HashCode.Combine(Slot.GetHashCode(), Pivot, GetExtents(), LeftChild?.GetHashCode() ?? 0, RightChild.GetHashCode());

		public override Range GetExtents() =>
			LeftChild is SPPFNode n
			? Math.Min(n.GetExtents().Start.Value, RightChild.GetExtents().Start.Value)..Math.Max(n.GetExtents().End.Value, RightChild.GetExtents().End.Value)
			: RightChild.GetExtents();

		public override string ToString() =>
			$"{Slot} @ {Pivot}";
	}
}